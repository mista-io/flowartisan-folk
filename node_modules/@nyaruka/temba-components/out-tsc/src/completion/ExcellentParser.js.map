{"version":3,"file":"ExcellentParser.js","sourceRoot":"","sources":["../../../src/completion/ExcellentParser.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,GAAG,CAAC,CAAC,CAAC,sBAAsB;AAC5C,MAAM,YAAY,GAAG,CAAC,CAAC,CAAC,qDAAqD;AAC7E,MAAM,gBAAgB,GAAG,CAAC,CAAC,CAAC,4DAA4D;AACxF,MAAM,cAAc,GAAG,CAAC,CAAC,CAAC,wEAAwE;AAClG,MAAM,oBAAoB,GAAG,CAAC,CAAC,CAAC,yCAAyC;AACzE,MAAM,oBAAoB,GAAG,CAAC,CAAC,CAAC,uCAAuC;AACvE,MAAM,YAAY,GAAG,CAAC,CAAC;AASvB;;GAEG;AACH,MAAM,UAAU,GAAG,CAAC,GAAW,EAAE,KAAa,EAAW,EAAE;IACzD,OAAO,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;AACrC,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,YAAY,GAAG,CACnB,iBAAyB,EACzB,gBAA0B,EAC1B,eAAwB,EACf,EAAE;IACX,MAAM,IAAI,GAAG,iBAAiB,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,eAAe;IAE5D,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACnB,OAAO,IAAI,CAAC;KACb;SAAM;QACL,4FAA4F;QAC5F,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC;QAElD,IAAI,eAAe,EAAE;YACnB,KAAK,MAAM,OAAO,IAAI,gBAAgB,EAAE;gBACtC,IAAI,UAAU,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE;oBACjC,OAAO,IAAI,CAAC;iBACb;aACF;SACF;aAAM;YACL,OAAO,gBAAgB,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SAChD;QACD,OAAO,KAAK,CAAC;KACd;AACH,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,EAAc,EAAW,EAAE;IACpD,OAAO,CACL,CAAC,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC;QACxB,CAAC,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC;QACxB,CAAC,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC;QACxB,EAAE,KAAK,GAAG,CACX,CAAC;AACJ,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,iBAAiB,GAAG,CAAC,iBAAyB,EAAW,EAAE;IAC/D,+BAA+B;IAC/B,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,KAAK,MAAM,GAAG,IAAI,iBAAiB,EAAE;QACnC,IAAI,GAAG,KAAK,GAAG,EAAE;YACf,SAAS,EAAE,CAAC;SACb;KACF;IACD,OAAO,SAAS,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,wCAAwC;AACtE,CAAC,CAAC;AAEF,MAAM,CAAC,OAAO,OAAO,eAAe;IAIlC;;;;OAIG;IACH,YAAY,gBAAwB,EAAE,gBAA0B;QAC9D,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;IAC3C,CAAC;IAED;;OAEG;IACI,iBAAiB,CAAC,WAAmB;QAC1C,MAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;YAC5B,uBAAuB;YACvB,OAAO,IAAI,CAAC;SACb;QAED,MAAM,cAAc,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAE3D,oFAAoF;QACpF,IAAI,cAAc,CAAC,GAAG,GAAG,WAAW,CAAC,MAAM,IAAI,cAAc,CAAC,MAAM,EAAE;YACpE,OAAO,IAAI,CAAC;SACb;QAED,OAAO,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,wBAAwB;IACnE,CAAC;IAED;;;OAGG;IACI,mBAAmB,CAAC,iBAAyB;QAClD,IAAI,iBAAiB,CAAC,iBAAiB,CAAC,EAAE;YACxC,OAAO,IAAI,CAAC;SACb;QAED,MAAM,iBAAiB,GAAG,EAAE,CAAC;QAC7B,IAAI,QAAQ,GAAG,EAAE,CAAC;QAClB,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,IAAI,WAAW,GAAG,EAAE,CAAC;QAErB,KAAK,IAAI,GAAG,GAAG,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE;YAC5D,MAAM,EAAE,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC;YAElC,IAAI,EAAE,KAAK,GAAG,EAAE;gBACd,QAAQ,GAAG,IAAI,CAAC;aACjB;YAED,IAAI,EAAE,KAAK,GAAG,EAAE;gBACd,QAAQ,GAAG,IAAI,CAAC;gBAChB,IAAI,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;oBAC3D,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBAC7B;aACF;YAED,IAAI,EAAE,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE;gBAC3B,QAAQ,GAAG,IAAI,CAAC;gBAChB,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC5B,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aAC7B;YAED,IAAI,EAAE,KAAK,GAAG,EAAE;gBACd,QAAQ,GAAG,CAAC,QAAQ,CAAC;aACtB;YAED,IAAI,QAAQ,EAAE;gBACZ,IAAI,EAAE,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE;oBAC3B,IAAI,iBAAiB,CAAC,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;wBAC3D,iBAAiB,CAAC,GAAG,EAAE,CAAC;qBACzB;oBAED,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;wBAClC,QAAQ,GAAG,KAAK,CAAC;qBAClB;iBACF;aACF;YAED,IAAI,EAAE,KAAK,GAAG,IAAI,QAAQ,KAAK,EAAE,EAAE;gBACjC,WAAW,GAAG,GAAG,CAAC;aACnB;YAED,IAAI,QAAQ,IAAI,QAAQ,IAAI,CAAC,EAAE,KAAK,GAAG,IAAI,QAAQ,KAAK,EAAE,CAAC,EAAE;gBAC3D,SAAS;aACV;YAED,IAAI,UAAU,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE;gBAChC,QAAQ,GAAG,EAAE,GAAG,QAAQ,CAAC;aAC1B;iBAAM;gBACL,MAAM;aACP;SACF;QAED,IAAI,QAAQ,CAAC,KAAK,CAAC,yBAAyB,CAAC,EAAE;YAC7C,OAAO,WAAW,GAAG,QAAQ,CAAC;SAC/B;aAAM;YACL,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAED;;OAEG;IACI,eAAe,CAAC,iBAAyB;QAC9C,MAAM,QAAQ,GAAG,iBAAiB,CAAC,iBAAiB,CAAC,CAAC;QAEtD,6DAA6D;QAC7D,IAAI,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,oBAAoB,CAAC,CAAC,CAAC,YAAY,CAAC;QAC3D,IAAI,UAAU,GAAG,EAAE,CAAC;QACpB,IAAI,gBAAgB,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAE7D,KAAK,IAAI,GAAG,GAAG,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE;YAC5D,MAAM,EAAE,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC;YAElC,IAAI,EAAE,KAAK,GAAG,EAAE;gBACd,OAAO,EAAE,CAAC;aACX;YAED,IAAI,KAAK,KAAK,YAAY,EAAE;gBAC1B,IAAI,gBAAgB,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,GAAG,CAAC,EAAE;oBAC5D,KAAK,GAAG,gBAAgB,CAAC;oBACzB,UAAU,GAAG,EAAE,GAAG,UAAU,CAAC;iBAC9B;qBAAM,IAAI,EAAE,KAAK,GAAG,EAAE;oBACrB,KAAK,GAAG,oBAAoB,CAAC;iBAC9B;qBAAM,IAAI,EAAE,KAAK,GAAG,EAAE;oBACrB,gBAAgB,EAAE,CAAC;iBACpB;qBAAM,IAAI,EAAE,KAAK,GAAG,EAAE;oBACrB,gBAAgB,EAAE,CAAC;iBACpB;aACF;iBAAM,IAAI,KAAK,KAAK,gBAAgB,EAAE;gBACrC,IAAI,UAAU,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE;oBAChC,UAAU,GAAG,EAAE,GAAG,UAAU,CAAC;iBAC9B;qBAAM;oBACL,OAAO,UAAU,CAAC;iBACnB;aACF;iBAAM,IAAI,KAAK,KAAK,oBAAoB,EAAE;gBACzC,IAAI,EAAE,KAAK,GAAG,EAAE;oBACd,KAAK,GAAG,YAAY,CAAC;iBACtB;aACF;SACF;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;IAEM,gBAAgB,CAAC,IAAY;QAClC,MAAM,MAAM,GAAG,EAAE,CAAC;QAClB,MAAM,EAAE,GAAG,oDAAoD,CAAC;QAChE,MAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC/C,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,IAAI,KAAK,CAAC;YACV,qDAAqD;YACrD,OAAO,CAAC,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE;gBACxC,MAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;aAClC;SACF;QACD,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7B,CAAC;IAED;;OAEG;IACI,eAAe,CAAC,IAAY;QACjC,MAAM,WAAW,GAAiB,EAAE,CAAC;QACrC,IAAI,KAAK,GAAG,UAAU,CAAC;QACvB,IAAI,iBAAiB,GAAe,IAAI,CAAC;QACzC,IAAI,gBAAgB,GAAG,CAAC,CAAC;QAEzB,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;YAC1C,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;YACrB,0GAA0G;YAC1G,iEAAiE;YACjE,MAAM,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzD,MAAM,UAAU,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAE7D,IAAI,KAAK,KAAK,UAAU,EAAE;gBACxB,IACE,EAAE,KAAK,IAAI,CAAC,gBAAgB;oBAC5B,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,MAAM,KAAK,GAAG,CAAC,EACtC;oBACA,KAAK,GAAG,YAAY,CAAC;oBACrB,iBAAiB,GAAG;wBAClB,KAAK,EAAE,GAAG;wBACV,GAAG,EAAE,IAAI;wBACT,IAAI,EAAE,EAAE;wBACR,MAAM,EAAE,KAAK;qBACd,CAAC;iBACH;qBAAM,IACL,EAAE,KAAK,IAAI,CAAC,gBAAgB;oBAC5B,MAAM,KAAK,IAAI,CAAC,gBAAgB,EAChC;oBACA,KAAK,GAAG,oBAAoB,CAAC;iBAC9B;aACF;iBAAM,IAAI,KAAK,KAAK,YAAY,EAAE;gBACjC,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE;oBAClB,KAAK,GAAG,gBAAgB,CAAC,CAAC,wCAAwC;iBACnE;qBAAM,IAAI,EAAE,KAAK,GAAG,EAAE;oBACrB,4CAA4C;oBAC5C,KAAK,GAAG,cAAc,CAAC;oBACvB,gBAAgB,IAAI,CAAC,CAAC;iBACvB;gBACD,iBAAiB,CAAC,IAAI,IAAI,EAAE,CAAC;aAC9B;iBAAM,IAAI,KAAK,KAAK,gBAAgB,EAAE;gBACrC,iBAAiB,CAAC,IAAI,IAAI,EAAE,CAAC;aAC9B;iBAAM,IAAI,KAAK,KAAK,cAAc,EAAE;gBACnC,IAAI,EAAE,KAAK,GAAG,EAAE;oBACd,gBAAgB,IAAI,CAAC,CAAC;iBACvB;qBAAM,IAAI,EAAE,KAAK,GAAG,EAAE;oBACrB,gBAAgB,IAAI,CAAC,CAAC;iBACvB;qBAAM,IAAI,EAAE,KAAK,GAAG,EAAE;oBACrB,KAAK,GAAG,oBAAoB,CAAC;iBAC9B;gBAED,iBAAiB,CAAC,IAAI,IAAI,EAAE,CAAC;gBAE7B,+CAA+C;gBAC/C,IAAI,gBAAgB,KAAK,CAAC,EAAE;oBAC1B,iBAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;iBACjC;aACF;iBAAM,IAAI,KAAK,KAAK,oBAAoB,EAAE;gBACzC,IAAI,EAAE,KAAK,GAAG,EAAE;oBACd,KAAK,GAAG,cAAc,CAAC;iBACxB;gBACD,iBAAiB,CAAC,IAAI,IAAI,EAAE,CAAC;aAC9B;iBAAM,IAAI,KAAK,KAAK,oBAAoB,EAAE;gBACzC,KAAK,GAAG,UAAU,CAAC;aACpB;YAED,iDAAiD;YACjD,gDAAgD;YAChD,kDAAkD;YAClD,uEAAuE;YACvE,IAAI,KAAK,KAAK,gBAAgB,EAAE;gBAC9B,IACE,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,MAAM,KAAK,GAAG,CAAC;oBACvC,CAAC,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,EAC3C;oBACA,iBAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;iBACjC;aACF;YAED,IACE,iBAAiB,IAAI,IAAI;gBACzB,CAAC,iBAAiB,CAAC,GAAG,IAAI,IAAI,IAAI,MAAM,KAAK,CAAC,CAAC,EAC/C;gBACA,MAAM,eAAe,GAAG,MAAM,KAAK,CAAC,CAAC,CAAC,iEAAiE;gBACvG,IACE,YAAY,CACV,iBAAiB,CAAC,IAAI,EACtB,IAAI,CAAC,gBAAgB,EACrB,eAAe,CAChB,EACD;oBACA,iBAAiB,CAAC,MAAM;wBACtB,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,gBAAgB,KAAK,CAAC,CAAC;oBAC9D,iBAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;oBAChC,WAAW,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;iBACrC;gBAED,iBAAiB,GAAG,IAAI,CAAC;gBACzB,KAAK,GAAG,UAAU,CAAC;aACpB;SACF;QAED,OAAO,WAAW,CAAC;IACrB,CAAC;CACF","sourcesContent":["const STATE_BODY = 0; // not in a expression\nconst STATE_PREFIX = 1; // '@' prefix that denotes the start of an expression\nconst STATE_IDENTIFIER = 2; // the identifier part, e.g. 'contact.age' in '@contact.age'\nconst STATE_BALANCED = 3; // the balanced parentheses delimited part, e.g. '(1 + 2)' in '@(1 + 2)'\nconst STATE_STRING_LITERAL = 4; // a string literal which could contain )\nconst STATE_ESCAPED_PREFIX = 5; // a '@' prefix preceded by another '@'\nconst STATE_IGNORE = 6;\n\nexport interface Expression {\n  start: number;\n  end: number;\n  text: string;\n  closed: boolean;\n}\n\n/**\n * Determines whether the given string starts with the given text\n */\nconst startsWith = (str: string, start: string): boolean => {\n  return str.indexOf(start, 0) === 0;\n};\n\n/**\n * Checks the parsed (possibly partial) expression to determine if it's valid based on how it starts\n */\nconst isValidStart = (\n  partialExpression: string,\n  allowedTopLevels: string[],\n  allowIncomplete: boolean\n): boolean => {\n  const body = partialExpression.substring(1); // strip prefix\n\n  if (body[0] === '(') {\n    return true;\n  } else {\n    // if expression doesn't start with ( then check it's an allowed top level context reference\n    const topLevel = body.split('.')[0].toLowerCase();\n\n    if (allowIncomplete) {\n      for (const allowed of allowedTopLevels) {\n        if (startsWith(allowed, topLevel)) {\n          return true;\n        }\n      }\n    } else {\n      return allowedTopLevels.indexOf(topLevel) >= 0;\n    }\n    return false;\n  }\n};\n\n/**\n * Determines whether the given character is a word character, i.e. \\w in a regex\n */\nexport const isWordChar = (ch: string | 0): boolean => {\n  return (\n    (ch >= 'a' && ch <= 'z') ||\n    (ch >= 'A' && ch <= 'Z') ||\n    (ch >= '0' && ch <= '9') ||\n    ch === '_'\n  );\n};\n\n/**\n * Determines whether we are in a string literal\n */\nconst isInStringLiteral = (partialExpression: string): boolean => {\n  // count number quotation marks\n  let numQuotes = 0;\n  for (const pos of partialExpression) {\n    if (pos === '\"') {\n      numQuotes++;\n    }\n  }\n  return numQuotes % 2 !== 0; // odd means last string literal is open\n};\n\nexport default class ExcellentParser {\n  private expressionPrefix: string;\n  private allowedTopLevels: string[];\n\n  /**\n   * Creates a new parser\n   * @param expressionPrefix the prefix for expressions, e.g. '@'\n   * @param allowedTopLevels the context names that are allowed without parentheses, e.g. [\"contact\", \"flow\", ...]\n   */\n  constructor(expressionPrefix: string, allowedTopLevels: string[]) {\n    this.expressionPrefix = expressionPrefix;\n    this.allowedTopLevels = allowedTopLevels;\n  }\n\n  /**\n   * Given the text up to the caret position, returns the expression currently being edited, without its prefix\n   */\n  public expressionContext(textToCaret: string): string {\n    const expressions = this.findExpressions(textToCaret);\n    if (expressions.length === 0) {\n      // no expressions found\n      return null;\n    }\n\n    const lastExpression = expressions[expressions.length - 1];\n\n    // has last expression already ended or is it closed (i.e. has balanced parentheses)\n    if (lastExpression.end < textToCaret.length || lastExpression.closed) {\n      return null;\n    }\n\n    return lastExpression.text.substring(1); // return without prefix\n  }\n\n  /**\n   * Given the partial expression currently being edited, returns the current auto-completable identifier\n   * which may be a function name or a context reference.\n   */\n  public autoCompleteContext(partialExpression: string): string {\n    if (isInStringLiteral(partialExpression)) {\n      return null;\n    }\n\n    const neededParentheses = [];\n    let fragment = '';\n    let skipChar = false;\n    let inQuotes = false;\n    let prependFlag = '';\n\n    for (let pos = partialExpression.length - 1; pos >= 0; pos--) {\n      const ch = partialExpression[pos];\n\n      if (ch === ' ') {\n        skipChar = true;\n      }\n\n      if (ch === ',') {\n        skipChar = true;\n        if (neededParentheses[neededParentheses.length - 1] !== '(') {\n          neededParentheses.push('(');\n        }\n      }\n\n      if (ch === ')' && !inQuotes) {\n        skipChar = true;\n        neededParentheses.push('(');\n        neededParentheses.push('(');\n      }\n\n      if (ch === '\"') {\n        inQuotes = !inQuotes;\n      }\n\n      if (skipChar) {\n        if (ch === '(' && !inQuotes) {\n          if (neededParentheses[neededParentheses.length - 1] === '(') {\n            neededParentheses.pop();\n          }\n\n          if (neededParentheses.length === 0) {\n            skipChar = false;\n          }\n        }\n      }\n\n      if (ch === '(' && fragment === '') {\n        prependFlag = '#';\n      }\n\n      if (skipChar || inQuotes || (ch === '(' && fragment === '')) {\n        continue;\n      }\n\n      if (isWordChar(ch) || ch === '.') {\n        fragment = ch + fragment;\n      } else {\n        break;\n      }\n    }\n\n    if (fragment.match(/[A-Za-z][\\w]*(\\.[\\w]+)*/)) {\n      return prependFlag + fragment;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * TODO find the function context\n   */\n  public functionContext(partialExpression: string): string {\n    const inString = isInStringLiteral(partialExpression);\n\n    // initial state is string literal if number of quotes is odd\n    let state = inString ? STATE_STRING_LITERAL : STATE_IGNORE;\n    let identifier = '';\n    let parenthesesLevel = partialExpression[-1] === '(' ? 0 : 1;\n\n    for (let pos = partialExpression.length - 1; pos >= 0; pos--) {\n      const ch = partialExpression[pos];\n\n      if (ch === '@') {\n        return '';\n      }\n\n      if (state === STATE_IGNORE) {\n        if (parenthesesLevel === 0 && (isWordChar(ch) || ch === '.')) {\n          state = STATE_IDENTIFIER;\n          identifier = ch + identifier;\n        } else if (ch === '\"') {\n          state = STATE_STRING_LITERAL;\n        } else if (ch === '(') {\n          parenthesesLevel--;\n        } else if (ch === ')') {\n          parenthesesLevel++;\n        }\n      } else if (state === STATE_IDENTIFIER) {\n        if (isWordChar(ch) || ch === '.') {\n          identifier = ch + identifier;\n        } else {\n          return identifier;\n        }\n      } else if (state === STATE_STRING_LITERAL) {\n        if (ch === '\"') {\n          state = STATE_IGNORE;\n        }\n      }\n    }\n    return '';\n  }\n\n  public getContactFields(text: string): string[] {\n    const fields = {};\n    const re = /((parent|child\\.)*contact\\.)*fields\\.([a-z0-9_]+)/g;\n    const expressions = this.findExpressions(text);\n    for (const expression of expressions) {\n      let match;\n      // tslint:disable-next-line:no-conditional-assignment\n      while ((match = re.exec(expression.text))) {\n        (fields as any)[match[3]] = true;\n      }\n    }\n    return Object.keys(fields);\n  }\n\n  /**\n   * Finds all expressions in the given text, including any partially complete expression at the end of the input\n   */\n  public findExpressions(text: string): Expression[] {\n    const expressions: Expression[] = [];\n    let state = STATE_BODY;\n    let currentExpression: Expression = null;\n    let parenthesesLevel = 0;\n\n    for (let pos = 0; pos < text.length; pos++) {\n      const ch = text[pos];\n      // in order to determine if the b in a.b terminates an identifier, we have to peek two characters ahead as\n      // it could be a.b. (b terminates) or a.b.c (b doesn't terminate)\n      const nextCh = pos < text.length - 1 ? text[pos + 1] : 0;\n      const nextNextCh = pos < text.length - 2 ? text[pos + 2] : 0;\n\n      if (state === STATE_BODY) {\n        if (\n          ch === this.expressionPrefix &&\n          (isWordChar(nextCh) || nextCh === '(')\n        ) {\n          state = STATE_PREFIX;\n          currentExpression = {\n            start: pos,\n            end: null,\n            text: ch,\n            closed: false,\n          };\n        } else if (\n          ch === this.expressionPrefix &&\n          nextCh === this.expressionPrefix\n        ) {\n          state = STATE_ESCAPED_PREFIX;\n        }\n      } else if (state === STATE_PREFIX) {\n        if (isWordChar(ch)) {\n          state = STATE_IDENTIFIER; // we're parsing an expression like @XXX\n        } else if (ch === '(') {\n          // we're parsing an expression like @(1 + 2)\n          state = STATE_BALANCED;\n          parenthesesLevel += 1;\n        }\n        currentExpression.text += ch;\n      } else if (state === STATE_IDENTIFIER) {\n        currentExpression.text += ch;\n      } else if (state === STATE_BALANCED) {\n        if (ch === '(') {\n          parenthesesLevel += 1;\n        } else if (ch === ')') {\n          parenthesesLevel -= 1;\n        } else if (ch === '\"') {\n          state = STATE_STRING_LITERAL;\n        }\n\n        currentExpression.text += ch;\n\n        // expression terminates if parentheses balance\n        if (parenthesesLevel === 0) {\n          currentExpression.end = pos + 1;\n        }\n      } else if (state === STATE_STRING_LITERAL) {\n        if (ch === '\"') {\n          state = STATE_BALANCED;\n        }\n        currentExpression.text += ch;\n      } else if (state === STATE_ESCAPED_PREFIX) {\n        state = STATE_BODY;\n      }\n\n      // identifier can terminate expression in 3 ways:\n      //  1. next char is null (i.e. end of the input)\n      //  2. next char is not a word character or period\n      //  3. next char is a period, but it's not followed by a word character\n      if (state === STATE_IDENTIFIER) {\n        if (\n          (!isWordChar(nextCh) && nextCh !== '.') ||\n          (nextCh === '.' && !isWordChar(nextNextCh))\n        ) {\n          currentExpression.end = pos + 1;\n        }\n      }\n\n      if (\n        currentExpression != null &&\n        (currentExpression.end != null || nextCh === 0)\n      ) {\n        const allowIncomplete = nextCh === 0; // if we're at the end of the input, allow incomplete expressions\n        if (\n          isValidStart(\n            currentExpression.text,\n            this.allowedTopLevels,\n            allowIncomplete\n          )\n        ) {\n          currentExpression.closed =\n            currentExpression.text[1] === '(' && parenthesesLevel === 0;\n          currentExpression.end = pos + 1;\n          expressions.push(currentExpression);\n        }\n\n        currentExpression = null;\n        state = STATE_BODY;\n      }\n    }\n\n    return expressions;\n  }\n}\n"]}