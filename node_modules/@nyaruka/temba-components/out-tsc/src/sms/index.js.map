{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/sms/index.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AACzC,OAAO,EAAE,eAAe,EAAE,MAAM,gBAAgB,CAAC;AACjD,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjD,MAAM,CAAC,MAAM,OAAO,GAAG,SAAS,CAAC;AACjC,MAAM,CAAC,MAAM,GAAG,GAAG,KAAK,CAAC;AAEzB,SAAS,kBAAkB,CAAC,KAAK,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS;IACnE,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,UAAU,CAAC;IAC1D,OAAO,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC;AAC3D,CAAC;AAED,MAAM,CAAC,MAAM,QAAQ,GAAG,UAAU,OAAe,EAAE,UAAe,EAAE;IAClE,MAAM,YAAY,GAAG,OAAO,IAAI,OAAO,CAAC,YAAY,CAAC;IAErD,OAAO,GAAG;QACR,OAAO,EAAE,OAAO,IAAI,OAAO,CAAC,OAAO;KACpC,CAAC;IAEF,MAAM,KAAK,GACT,CAAC,YAAY,KAAK,SAAS,IAAI,eAAe,CAAC,OAAO,CAAC,CAAC;QACxD,YAAY,KAAK,GAAG,CAAC;IACvB,IAAI,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS,CAAC;IAEpD,IAAI,KAAK,EAAE;QACT,WAAW,GAAG,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACzC,WAAW,GAAG,GAAG,CAAC;QAClB,UAAU,GAAG,GAAG,CAAC;QACjB,SAAS,GAAG,CAAC,CAAC;KACf;SAAM;QACL,WAAW,GAAG,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAC7C,WAAW,GAAG,GAAG,CAAC;QAClB,UAAU,GAAG,GAAG,CAAC;QACjB,SAAS,GAAG,CAAC,CAAC;KACf;IAED,MAAM,eAAe,GAAG,kBAAkB,CACxC,WAAW,CAAC,KAAK,EACjB,WAAW,EACX,UAAU,EACV,SAAS,CACV,CAAC;IAEF,OAAO;QACL,YAAY,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO;QACnC,KAAK,EAAE,WAAW,CAAC,KAAK;QACxB,KAAK,EAAE,WAAW,CAAC,UAAU;QAC7B,MAAM,EAAE,WAAW,CAAC,WAAW;QAC/B,eAAe,EAAE,eAAe;KACjC,CAAC;AACJ,CAAC,CAAC","sourcesContent":["/**\n * This is the same SMS splitter we've been using but we've\n * updated it here to use it with ESM imports\n * See https://github.com/Codesleuth/split-sms\n */\n\nimport { gsmSplit } from './gsmsplitter';\nimport { validateMessage } from './gsmvalidator';\nimport { unicodeSplit } from './unicodesplitter';\n\nexport const UNICODE = 'Unicode';\nexport const GSM = 'GSM';\n\nfunction calculateRemaining(parts, singleBytes, multiBytes, charBytes) {\n  const max = parts.length === 1 ? singleBytes : multiBytes;\n  return (max - parts[parts.length - 1].bytes) / charBytes;\n}\n\nexport const splitSMS = function (message: string, options: any = {}) {\n  const characterset = options && options.characterset;\n\n  options = {\n    summary: options && options.summary,\n  };\n\n  const isGsm =\n    (characterset === undefined && validateMessage(message)) ||\n    characterset === GSM;\n  let splitResult, singleBytes, multiBytes, charBytes;\n\n  if (isGsm) {\n    splitResult = gsmSplit(message, options);\n    singleBytes = 160;\n    multiBytes = 153;\n    charBytes = 1;\n  } else {\n    splitResult = unicodeSplit(message, options);\n    singleBytes = 140;\n    multiBytes = 134;\n    charBytes = 2;\n  }\n\n  const remainingInPart = calculateRemaining(\n    splitResult.parts,\n    singleBytes,\n    multiBytes,\n    charBytes\n  );\n\n  return {\n    characterSet: isGsm ? GSM : UNICODE,\n    parts: splitResult.parts,\n    bytes: splitResult.totalBytes,\n    length: splitResult.totalLength,\n    remainingInPart: remainingInPart,\n  };\n};\n"]}