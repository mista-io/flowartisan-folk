import { __decorate } from "tslib";
import { geoJSON, map as createMap, } from 'leaflet';
import { css, html, LitElement } from 'lit';
import { property } from 'lit/decorators';
import { getUrl } from '../utils';
import { highlightedFeature, normalFeature, visibleStyle } from './helpers';
export class LeafletMap extends LitElement {
    constructor() {
        super();
        this.osmId = '';
        this.endpoint = '';
        this.hovered = null;
        this.path = [];
        this.renderedMap = null;
        this.states = null;
        this.paths = {};
        this.lastHovered = null;
    }
    static get styles() {
        return css `
      :host {
        display: block;
        padding: 0px;
      }

      #alias-map {
        top: 0px;
        height: 100%;
      }

      .leaflet-container {
        background: transparent;
      }

      .path {
        position: absolute;
        color: #666;
      }

      .path > .step {
        display: inline-block;
        font-size: 12px;
        margin-left: 5px;
      }

      .path > .step.hovered {
        color: #999;
      }

      .path > .step.linked {
        text-decoration: underline;
        color: var(--color-link-primary);
        cursor: pointer;
      }
    `;
    }
    getRenderRoot() {
        return this.renderRoot;
    }
    getEndpoint() {
        return this.endpoint + (!this.endpoint.endsWith('/') ? '/' : '');
    }
    refreshMap() {
        const onEachFeature = (feature, path) => {
            this.paths[feature.properties.osm_id] = path;
            path.on({
                click: (event) => {
                    const feature = event.target.feature.properties;
                    if (feature.osm_id !== this.path[this.path.length - 1].osm_id) {
                        const orig = event.originalEvent;
                        orig.stopPropagation();
                        orig.preventDefault();
                        if (this.onFeatureClicked) {
                            this.onFeatureClicked(feature);
                        }
                        this.hovered = null;
                        this.path.push(feature);
                        this.osmId = feature.osm_id;
                        this.refreshMap();
                    }
                },
                mouseover: (event) => {
                    const feature = event.target.feature.properties;
                    if (feature.osm_id !== this.path[this.path.length - 1].osm_id) {
                        event.target.setStyle(highlightedFeature);
                        this.hovered = feature;
                    }
                },
                mouseout: (event) => {
                    event.target.setStyle(normalFeature);
                    this.hovered = null;
                },
            });
        };
        getUrl(this.getEndpoint() + 'geometry/' + this.osmId + '/').then((response) => {
            if (this.states) {
                this.renderedMap.removeLayer(this.states);
            }
            const data = response.json;
            if (this.path.length === 0) {
                this.path = [
                    {
                        name: data.name,
                        osm_id: this.osmId,
                        level: 0,
                    },
                ];
            }
            this.states = geoJSON(data.geometry, {
                style: visibleStyle,
                onEachFeature,
            });
            this.renderedMap.fitBounds(this.states.getBounds(), {});
            this.states.addTo(this.renderedMap);
        });
    }
    updated(changedProperties) {
        if (changedProperties.has('hovered')) {
            if (this.lastHovered) {
                this.lastHovered.setStyle(normalFeature);
            }
            if (this.hovered) {
                const layer = this.paths[this.hovered.osm_id];
                this.lastHovered = layer;
                if (layer) {
                    layer.setStyle(highlightedFeature);
                }
            }
        }
        if (changedProperties.has('feature') && this.feature) {
            this.hovered = null;
            if (this.path.length === 0 ||
                this.path[this.path.length - 1].osm_id !== this.feature.osm_id) {
                this.path.push(this.feature);
            }
        }
        if (changedProperties.has('osmId')) {
            const path = [];
            for (const feature of this.path) {
                path.push(feature);
                if (feature.osm_id === this.osmId) {
                    if (this.onFeatureClicked) {
                        this.onFeatureClicked(feature);
                    }
                    break;
                }
            }
            this.path = path;
            this.refreshMap();
        }
    }
    firstUpdated(changedProperties) {
        const mapElement = this.getRenderRoot().getElementById('alias-map');
        this.renderedMap = createMap(mapElement, {
            attributionControl: false,
            scrollWheelZoom: false,
            zoomControl: false,
        }).setView([0, 1], 4);
        this.renderedMap.dragging.disable();
        this.renderedMap.doubleClickZoom.disable();
        this.refreshMap();
        super.firstUpdated(changedProperties);
    }
    handleClickedBreadcrumb(e) {
        this.osmId = e.currentTarget.getAttribute('data-osmid');
        const path = [];
        for (const feature of this.path) {
            path.push(feature);
            if (feature.osm_id === this.osmId) {
                if (this.onFeatureClicked) {
                    this.onFeatureClicked(feature);
                }
                break;
            }
        }
        this.path = path;
        this.refreshMap();
    }
    render() {
        if (!this.osmId) {
            return html `<div>No osm map id</div>`;
        }
        return html `
      <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
      />
      <div id="alias-map"></div>
    `;
    }
}
__decorate([
    property()
], LeafletMap.prototype, "feature", void 0);
__decorate([
    property()
], LeafletMap.prototype, "osmId", void 0);
__decorate([
    property()
], LeafletMap.prototype, "endpoint", void 0);
__decorate([
    property()
], LeafletMap.prototype, "onFeatureClicked", void 0);
__decorate([
    property()
], LeafletMap.prototype, "hovered", void 0);
__decorate([
    property()
], LeafletMap.prototype, "path", void 0);
//# sourceMappingURL=LeafletMap.js.map