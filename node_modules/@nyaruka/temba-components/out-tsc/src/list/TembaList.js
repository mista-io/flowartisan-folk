import { __decorate } from "tslib";
import { css, html } from 'lit';
import { property } from 'lit/decorators';
import { reset } from 'sinon';
import { CustomEventType } from '../interfaces';
import { RapidElement } from '../RapidElement';
import { fetchResultsPage } from '../utils';
const DEFAULT_REFRESH = 10000;
export class TembaList extends RapidElement {
    constructor() {
        super();
        this.items = [];
        this.cursorIndex = -1;
        this.tabIndex = 1;
        this.valueKey = 'id';
        this.loading = false;
        // changes to the refresh key force a refresh
        this.refreshKey = '0';
        // our next page from our endpoint
        this.nextPage = null;
        this.pages = 0;
        this.pending = [];
        this.refreshInterval = null;
        this.handleSelection.bind(this);
    }
    static get styles() {
        return css `
      :host {
        display: block;
        height: 100%;
        width: 100%;
      }

      temba-options {
        display: block;
        width: 100%;
        flex-grow: 1;
      }

      .wrapper {
        display: flex;
        flex-direction: column;
        height: 100%;
        align-items: center;
      }
    `;
    }
    reset() {
        this.selected = null;
        this.nextPage = null;
        this.cursorIndex = -1;
        this.mostRecentItem = null;
        this.items = [];
    }
    connectedCallback() {
        super.connectedCallback();
        this.refreshInterval = setInterval(() => {
            this.refreshKey = 'default_' + new Date().getTime();
        }, DEFAULT_REFRESH);
    }
    disconnectedCallback() {
        clearInterval(this.refreshInterval);
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (changedProperties.has('endpoint') && this.endpoint) {
            // if our tests aren't preserving our properties, reset
            if (!this.preserve) {
                this.reset();
                this.loading = true;
            }
            this.httpComplete = this.fetchItems();
        }
        if (changedProperties.has('refreshKey') &&
            !changedProperties.has('endpoint')) {
            this.refreshTop();
        }
        if (changedProperties.has('mostRecentItem')) {
            this.fireCustomEvent(CustomEventType.Refreshed);
        }
        if (changedProperties.has('cursorIndex')) {
            if (this.cursorIndex > -1) {
                this.selected = this.items[this.cursorIndex];
                this.handleSelected(this.selected);
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    handleSelected(selected) {
        const evt = new Event('change', { bubbles: true });
        this.dispatchEvent(evt);
    }
    getValue(obj) {
        if (!obj) {
            return null;
        }
        const path = this.valueKey.split('.');
        let current = obj;
        while (path.length > 0) {
            const key = path.shift();
            current = current[key];
        }
        return current;
    }
    setSelection(value) {
        const index = this.items.findIndex(item => {
            return this.getValue(item) === value;
        });
        this.cursorIndex = index;
        this.selected = this.items[index];
        const evt = new Event('change', { bubbles: true });
        this.dispatchEvent(evt);
    }
    getItemIndex(value) {
        return this.items.findIndex(option => this.getValue(option) === value);
    }
    removeItem(value) {
        const index = this.getItemIndex(value);
        this.items.splice(index, 1);
        this.items = [...this.items];
        // if we were at the end, move us down
        this.cursorIndex = Math.max(0, Math.min(this.items.length - 1, this.cursorIndex - 1));
        // request a change even if it is the same, the item is different
        this.requestUpdate('cursorIndex');
        this.requestUpdate('items');
    }
    getSelection() {
        return this.selected;
    }
    refresh() {
        this.refreshKey = 'requested_' + new Date().getTime();
    }
    setEndpoint(endpoint, nextSelection = null) {
        this.endpoint = endpoint;
        this.nextSelection = nextSelection;
    }
    getRefreshEndpoint() {
        return this.endpoint;
    }
    /**
     * Refreshes the first page, updating any found items in our list
     */
    async refreshTop() {
        // cancel any outstanding requests
        while (this.pending.length > 0) {
            const pending = this.pending.pop();
            pending.abort();
        }
        const controller = new AbortController();
        this.pending.push(controller);
        const prevItem = this.items[this.cursorIndex];
        try {
            const page = await fetchResultsPage(this.getRefreshEndpoint(), controller);
            const items = [...this.items];
            // remove any dupes already in our list
            if (page.results) {
                page.results.forEach((newOption) => {
                    if (this.sanitizeOption) {
                        this.sanitizeOption(newOption);
                    }
                    const newValue = this.getValue(newOption);
                    const removeIndex = items.findIndex(option => this.getValue(option) === newValue);
                    if (removeIndex > -1) {
                        items.splice(removeIndex, 1);
                    }
                });
                // insert our new items at the front
                const newItems = [...page.results.reverse(), ...items];
                if (prevItem) {
                    const newItem = newItems[this.cursorIndex];
                    const prevValue = this.getValue(prevItem);
                    if (prevValue !== this.getValue(newItem)) {
                        const newIndex = newItems.findIndex(option => this.getValue(option) === prevValue);
                        this.cursorIndex = newIndex;
                        // make sure our focused item is visible
                        window.setTimeout(() => {
                            const options = this.shadowRoot.querySelector('temba-options');
                            if (options) {
                                const option = options.shadowRoot.querySelector('.option.focused');
                                option.scrollIntoView({ block: 'end', inline: 'nearest' });
                            }
                        }, 0);
                    }
                }
                this.items = newItems;
            }
        }
        catch (error) {
            console.error(error);
        }
    }
    async fetchItems() {
        // cancel any outstanding requests
        while (this.pending.length > 0) {
            const pending = this.pending.pop();
            pending.abort();
        }
        let endpoint = this.endpoint;
        let pagesToFetch = this.pages || 1;
        let pages = 0;
        let nextPage = null;
        let fetchedItems = [];
        while (pagesToFetch > 0 && endpoint) {
            const controller = new AbortController();
            this.pending.push(controller);
            try {
                const page = await fetchResultsPage(endpoint, controller);
                // sanitize our options if necessary
                if (this.sanitizeOption) {
                    page.results.forEach(this.sanitizeOption);
                }
                if (page.results) {
                    fetchedItems = fetchedItems.concat(page.results);
                }
                // save our next pages
                nextPage = page.next;
                endpoint = nextPage;
                pagesToFetch--;
                pages++;
            }
            catch (error) {
                // aborted
                reset();
                return;
            }
            this.nextPage = nextPage;
        }
        this.pages = pages;
        const topItem = fetchedItems[0];
        if (!this.mostRecentItem ||
            JSON.stringify(this.mostRecentItem) !== JSON.stringify(topItem)) {
            this.mostRecentItem = topItem;
        }
        // see if our cursor needs to move to stay on the same item
        const newItem = fetchedItems[this.cursorIndex];
        if (!this.nextSelection &&
            this.selected &&
            newItem &&
            this.getValue(newItem) !== this.getValue(this.selected)) {
            const index = fetchedItems.findIndex(item => {
                return this.getValue(item) === this.getValue(this.selected);
            });
            // old selection is in the new fetch
            if (index > -1) {
                this.cursorIndex = index;
            }
            // old selection is missing from the new fetch
            else {
                // if our index didn't change, our item still did, fire change
                if (this.cursorIndex === 0) {
                    this.requestUpdate('cursorIndex');
                }
                // otherwise select the first item
                else {
                    this.cursorIndex = 0;
                }
            }
        }
        // save our results
        this.items = fetchedItems;
        this.loading = false;
        this.pending = [];
        if (this.nextSelection) {
            this.setSelection(this.nextSelection);
            this.nextSelection = false;
        }
        else {
            if (this.cursorIndex === -1) {
                this.cursorIndex = 0;
            }
        }
        // TODO: Not sure why this is needed
        // this.requestUpdate('cursorIndex');
        if (this.value) {
            this.setSelection(this.value);
            this.value = null;
        }
        return Promise.resolve();
    }
    handleScrollThreshold() {
        if (this.nextPage && !this.loading) {
            this.loading = true;
            fetchResultsPage(this.nextPage).then((page) => {
                if (this.sanitizeOption) {
                    page.results.forEach(this.sanitizeOption);
                }
                this.items = [...this.items, ...page.results];
                this.nextPage = page.next;
                this.pages++;
                this.loading = false;
            });
        }
    }
    handleSelection(event) {
        const { selected, index } = event.detail;
        this.selected = selected;
        this.cursorIndex = index;
        event.stopPropagation();
        event.preventDefault();
    }
    render() {
        return html `<div class="wrapper">
      <temba-options
        ?visible=${true}
        ?block=${true}
        ?collapsed=${this.collapsed}
        ?loading=${this.loading}
        .renderOption=${this.renderOption}
        .renderOptionDetail=${this.renderOptionDetail}
        @temba-scroll-threshold=${this.handleScrollThreshold}
        @temba-selection=${this.handleSelection.bind(this)}
        .options=${this.items}
        .cursorIndex=${this.cursorIndex}
      >
        <slot></slot>
      </temba-options>
    </div>`;
    }
}
__decorate([
    property({ type: Array, attribute: false })
], TembaList.prototype, "items", void 0);
__decorate([
    property({ type: Object, attribute: false })
], TembaList.prototype, "selected", void 0);
__decorate([
    property({ type: Number })
], TembaList.prototype, "cursorIndex", void 0);
__decorate([
    property({ type: String })
], TembaList.prototype, "endpoint", void 0);
__decorate([
    property({ type: String })
], TembaList.prototype, "nextSelection", void 0);
__decorate([
    property({ type: Number })
], TembaList.prototype, "tabIndex", void 0);
__decorate([
    property({ type: String })
], TembaList.prototype, "valueKey", void 0);
__decorate([
    property({ type: String })
], TembaList.prototype, "value", void 0);
__decorate([
    property({ type: Boolean })
], TembaList.prototype, "loading", void 0);
__decorate([
    property({ type: Boolean })
], TembaList.prototype, "collapsed", void 0);
__decorate([
    property({ attribute: false })
], TembaList.prototype, "getNextRefresh", void 0);
__decorate([
    property({ attribute: false })
], TembaList.prototype, "sanitizeOption", void 0);
__decorate([
    property({ attribute: false })
], TembaList.prototype, "renderOption", void 0);
__decorate([
    property({ attribute: false })
], TembaList.prototype, "renderOptionDetail", void 0);
__decorate([
    property({ attribute: false, type: Object })
], TembaList.prototype, "mostRecentItem", void 0);
__decorate([
    property({ type: String })
], TembaList.prototype, "refreshKey", void 0);
//# sourceMappingURL=TembaList.js.map